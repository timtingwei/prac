#include <iostream>
using std::cin; using std::cout; using std::endl;

//求数的阶乘的程序
//编写函数
//val的阶乘是val*(val-1)*(val-2)*...*(val-(val-1))
int fact(int n) {
	int ret = 1;   //定义一个局部变量记录结果
	while (n > 1)
		ret *= n--; //把ret和n的乘积赋给ret,然后将n减1
	
	return ret;    //返回结果
	//函数结束执行过程
	//1 返回return语句中的值（如果有的话）
	//2 将控制权从被调用函数移动回主函数。
}

//调用函数



int basic_of_function_61()
{
	int val = 5;  //阶乘数为5
	int j = fact(val);   //调用 fact函数，返回5的阶乘，作为j的初始值。
	//实参初始化函数对应的形参，二是将控制权转移给被调用的函数。主调函数(calling funtion)的执行被暂时中断，被调函数(called function)开始执行。 
	//函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分
	cout << "5! is  " << j << endl;

	/*
	//等价于
	int val = 5;       //用字面值5初始化val
	int ret = 1;       //fact函数体内的代码
	while (val > 1)
		ret *= val--;
	int j = ret;       //用ret的副本初始化j*/

	system("pause");  //怎么pause不住了..  前面错打了return
	return 0;
}
//当调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调用时所用的实参5


//形参和实参
//实参是形参的初始值。实参1初始化实参2。尽管存在对应关系，但是并没有规定实参的求值顺序
//实参和形参类型要相互匹配，（匹配不等于相同）存在转换，和之前的规则相同
//因为规定 实参数 和 形参数 相同，所以形参一定会被初始化
/*int main2()
{
	//fact函数只有一个int类型的 形参，所以调用的时候 必须提供一个可转换的
	fact("hello");   //错误: const char*不能转换成int
	fact();          //错误:实参数量不足
	fact(42, 10, 0); //错误:实参数量过多
	fact(3.14);      //正确:double类型隐式转换成int类型  等价于 fact(3)

}*/

//函数的形参列表
//形参列表可以为空，但是不能省略。想要定义一个不带形参的函数，可以书写一个空的形参列表。
//不过与C语言兼容，也可以使用关键字void表示函数没有形参:
void f1(){/*...*/}     //隐式定义空形参列表
void f2(void){/*...*/}    //显式定义空形参列表

//形参列表通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来！！！
//int f3(int v1,v2){/*...*/}       //错误:v2是未定义的标识符
//int f4(int v1, int v2){/*...*/}    //正确:必须把每个类型都写出来

//任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字
int f5(int v1, int v2) {
	//int v1 = 5;    //形参v1重定义,外层作用域不能使用和函数形参一样的名字
	v1 = 5;          //给变量v1赋值，并非定义

	for (int v1 = 0; v1 < 10; ++v1)   //内层作用域可以重新定义
		cout << v1 << endl;
	return 0;
}

//函数的返回类型

//大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值
//void f6() {
	//return 0;   //void的函数不能返回任何值
//}

//函数的返回值类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
int v7(int val) {   //其实已经定义了函数返回值的类型
	int iarr[3] = { 1,2,3 };
	//return iarr;        //无法从将 int转换为 int 
	int(*parr)[3] = &iarr;   //parr是指向数组的指针
	cout << *parr;
	return 0;
}




//后面章节将会介绍两个概念：返回值是数组的指针（或者引用）  如何返回指向函数的指针  