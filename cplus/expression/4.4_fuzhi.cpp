#include <iostream>
#include <vector>
#include <string>

using std::cin; using std::cout; using std::endl;
using std::vector;
using std::string;

int fuzhi_44()
{
	//赋值运算符的左侧运算器必须是一个可修改的左值 
	int i = 0, j = 0, k = 0;       //初始化而非赋值
	const int ci = i;              //初始化 

	//1024 = k;         //错误:字面值是右值（内容）
	//i + j = k;        //错误:算术表达式是右值（内容)
	//ci = k;           //错误:ci是一个不可修改的左值

	//赋值运算的结果是它左侧运算对象，并且是一个左值。结果的类型就是左侧运算对象的类型。
	//如果赋值运算的左右两类型不同，将右类型转换成左类型

	k = 0;              //结果：类型是int,值是0
	//k = 3.1415926;      //结果：类型是int，值是3

	//c++新标准允许使用花括号括起来的初始值列表，作为赋值语句的右侧运算对象
	//k = { 3.14 };         //错误：狭窄转换
	vector<int> vi;           //初始为空
	vi = { 0,1,2,3,4,5,6,7,8,9 };   //类型是vector<int>,值是含有10个元素的列表
	//左侧对象为内置类型时，那么初始值列表最多只能包含一个值，而且该值即使转换的话也不应该大于目标类型空间
	k = { 3 };             //正确：并非狭窄转换

	//赋值运算满足右结合律 
	int ival, jval;
	ival = jval = 0;      
	//靠右的赋值运算 作为 靠左的赋值运算符的 右侧运算对象
	//对于多重的赋值运算，他的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到
	//int ival, *pval;
	//ival = pval = 0;   //不能把指针的值赋给int
	string s1, s2;
	s1 = s2 = "OK";   //字符串字面值可以转换成string对象，并赋给s2，而s2和s1的类型相同，s2值继续赋给s1

	//赋值运算的优先级较低，可以用()符合原意
	
	/*//这是一种形式繁琐、容易出错的写法
	int i = get_value();  //得到第一个值
	while (i != 42) {
		//其他处理...
		i = get_value();      //得到剩下的值
	}

	//简单形式
	int i;
	while ((i = get_value()) != 42) {
		//其他处理...
	}
	//首先将get_value函数的返回值赋给1，然后比较i和42是否相同
	//这里如果不加括号，由于赋值运算优先级较低，先比较 get_value() 和 42，得到bool值赋值给i*/

	int i1 = 5, j1 = 1;
	if (i1 = j1)   //原意可能是  if ( i1==j1)
		cout << i1 << endl;

	//符合赋值运算符
	int sum = 0;
	for (int i = 1; i != 10; ++i)
		sum += i;
	cout << sum << endl;
	//+=   -=   *=   /=   %=   //算术运算符
	//<<=  >>=  &=   ^=   |=   //位运算符
	//左侧运算对象求值次数，符合运算符求一次，普通运算符号先求子表达式的值，再对左侧运算对象求值



		

	system("pause");
	return 0;
}