#include <iostream>
#include <vector>

using std::cin; using std::cout; using std::endl;
using std::vector;

int basic_411()
{
	//基本概念

	//表达式由一个或者多个运算对象组成，对表达式求值将得到一个结果，字面值和变量是最简单的表达式，结果就是字面值和变量的值。
	//字符和一个或者多个运算对象组合起来可以生成较为复杂的表达式

    //一元运算符：取地址符 & ，解引用 *
	//二元运算符： == * 
	//三元运算符： 作用于三个运算对象的三元运算符
	//符号既能作为一元运算符，也能作为三元运算符

	//组合运算符和运算对象
	//多个运算符的复杂表达式，要理解运算符的 优先级 结合律 以及运算对象的结合顺序

	//运算对象转换
	//一般的二元运算要求两个运算对象的类型相同。
	//整数能转换成浮点，浮点能转换成整数，但指针不能转换成浮点数
	//小整型（bool、char、short等）通常会被 提升(promoted) 较大的整数类型，主要是 int 

	//重载运算符
	//定义 已经存在的运算符 赋予另外一层含义
	//使用 重载运算符时， 运算对象的类型和返回值的类型，都是由该运算符定义的。不变的是运算对象的个数，运算符的优先级和结合律都是无法改变的


	//左值和右值
	//c中 左值可以位于赋值语句的左侧，右值则不能。
	//c++中比较复杂。
	//当一个对象被用作右值时，用的是对象的值（内容）；当对象被用左值的时候，用的是对象的身份（内存中的位置）
	//不同运算符对运算对象的要求各不相同，右需要左值运算对象也有右值运算对象；返回值有左值结果，也有右值结果
	//当一个左值被用作右值时，用的是他的内容（值）。左值可以充当右值，右值不能充当左值(地址)

	//赋值运算符 需要一个（非常量）左值作为其左值对象，得到的结果也仍然是一个左值
	int i, j;
	i = 24;
	//24 = j;    //错误：表达式必须是可以修改的左值，不能是一个常量
	
	//取地址符 作用于一个左值运算对象，返回一个指向该运算对象的指针，指针是一个右值。
	auto p = &i;     //i作为左值充当内容，p作为右值作为内容。
	cout << *p << endl;

	//内容解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值.
	*p;
	vector<int> iarr = { 1,2,3,4 };
	iarr[1];     //为什么它们的求值结果是左值，而不是右值

	//内置类型和迭代器的递增递减运算符，作用于左值对象，其前置版本所得的结果也是左值
	vector<int> iarr1 = { 0,1,2,3,4 };
	//for (decltype(iarr1.size()) ix = 0; ix != iarr1.size(); ++ix)
	    //cout << iarr1[ix] << endl;
	for (auto ix = iarr1.begin(); ix != iarr1.end();++ix)   //++ix属于前置类型，所得结果是左值，是一个位置
		cout << *ix << endl;

	//使用关键值decltype左右值有所不同
	//如果表达式的求值结果是左值，decltype作用域该表达式（不是变量）得到一个引用类型
	//decltype(*p) ix =      //解引用得到左值，所以decltype(*p)的结果是一个int&


	system("pause");
	return 0;

}

/*//取地址符 作用于一个左值运算对象，返回一个指向该运算对象的指针，指针是一个右值。
auto p = &i;     //i作为左值充当内容，p作为右值作为内容。
cout << *p << endl;
//内容解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值.
*p;
vector<int> iarr = { 1,2,3,4 };
iarr[1];     //下标运算符得到iarr[1]的内容，为什么结果是左值，而不是右值？？*/