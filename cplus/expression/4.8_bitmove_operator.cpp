#include <iostream>
#include <vector>
#include <string>

using std::cin; using std::cout; using std::endl;
using std::vector;
using std::string;

int bitmove_operator_48()
{
	//位运算符
	//位运算符作用于整数类型的运算对象，并把运算对象看成是二进制的集合。
	//位运算符提供 检查 和 设置 二进制位的功能

	//位运算符满足左结合律 
	// ^位求反 <<左移 >>右移 &位与 ^位异或 |位或
	
	//强烈建议 仅将位运算符用于处理无符号类型
	 
	/*//移动位运算符 
	unsigned char bits = 0233;
	// 00000000 00000000 00000000 10011011
	bits << 8;  //bit被提升成int类型，然后向左移动8位
	// 00000000 00000000 10011011 00000000
	bits << 32; //向左移动31位，左边超出边界的位丢弃掉
	// 10000000 00000000 00000000 00000000
	bits >> 3;  //向右移动3位，最右边的3位丢弃掉
	// 00000000 00000000 00000000 00010011*/

	//位求反(~)
	unsigned char bits = 0227;
	// 00000000 00000000 00000000 10010111
	~bits;
	// 11111111 11111111 11111111 01101000

	//位与& 位或|  位异或^
	unsigned char b1 = 0145;     //01100101
	unsigned char b2 = 0257;     //10101111
	b1 & b2;      //24个高阶都是0   00100101
	b1 | b2;      //24个高阶都是0   11101111
	b1 ^ b2;      //24个高阶都是0   11001010

	unsigned long quiz1 = 0;   //我们把这个值当成是位的集合使用
	//unsigned long 在任何机器上都是32位

	1UL << 27;
	//1UL     00000000 00000000 00000000 00000001
	//1UL<<27 00000100 00000000 00000000 00000000

	//使用一个赋值语句 
	quiz1 |= 1UL << 27;           //表示学生27通过了测验
	//等价于
	quiz1 = quiz1 | 1UL<< 27;

	//~(1UL << 27)对对象取反，得到27位为0，其他所有位都是1的值
	quiz1 &= ~(1UL << 27);       //学生27没有通过测验
	
	//quiz1和一个只有第27位是1的值按位求与，如果quiz1的第27位是0，如果27位1，计算结果就是非0(真)；否则结果是0
	bool status = quiz1 & (1UL << 27);        //学生27是否通过测试？

	cout << status << endl;

	//移位运算符满足左结合律
	cout << "hello" << "world" << endl;
	(((cout << "hello") << "world") << endl);   //执行过程等同于上述语句

	cout << 42 + 10;     //正确：+的优先级更高，因此输出求和结果 
	cout << (42 + 10);   //正确：用括号按照期望组合在一起
	//cout << 42 < 10;     //错误：<<的优先级高于<，cout的值为42，与10进行比较
	//最后一个含义其实是 
	//(cout << 42) < 10;
	//把数字42写到cout，然后将结果(cout)与10进行比较
	system("pause");
	return 0;
}
